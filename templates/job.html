<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Processing - MistraLOCR</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230c0c0c' width='100' height='100'/><text y='70' x='50' text-anchor='middle' font-size='60' fill='%23c8ff00'>O</text></svg>">
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}?v=10" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,500;0,600;1,400&display=swap">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>

<div class="job-screen" x-data="jobStatus('{{ job_id }}', '{{ status }}', '{{ download_url|default('', true) }}', '{{ error|default('', true) }}')">
  <!-- Full screen grid background -->
  <div class="screen-grid" :class="{ 'active': isProcessing, 'success': status === 'done', 'error': status === 'error' }"></div>

  <!-- Header -->
  <header class="header">
    <a href="{{ url_for('index') }}" class="logo">MISTRALOCR</a>
    <div class="job-id">{{ job_id[:8] }}</div>
  </header>

  <!-- Center content -->
  <main class="job-center" :class="{ 'has-preview': showPreview }">
    <div class="job-status-box" x-show="!showPreview">
      <!-- Status symbol -->
      <div class="status-symbol" :class="status">
        <span x-text="statusIcon"></span>
      </div>

      <!-- Current message -->
      <div class="current-message" x-text="currentMessage"></div>

      <!-- Action buttons -->
      <div x-show="status === 'done'" x-transition class="action-buttons">
        <button @click="loadPreview()" class="preview-btn" :disabled="previewLoading">
          <span x-show="!previewLoading">Preview</span>
          <span x-show="previewLoading">Loading...</span>
        </button>
        <a :href="downloadUrl" class="download-btn">Download</a>
      </div>

      <!-- Error display -->
      <div x-show="status === 'error'" x-transition class="error-box">
        <span x-text="errorMsg"></span>
      </div>
    </div>

    <!-- Preview Panel -->
    <div x-show="showPreview" x-transition class="preview-panel">
      <div class="preview-header">
        <button @click="showPreview = false" class="close-preview-btn">&larr; Back</button>
        <div class="preview-title">Preview</div>
        <a :href="downloadUrl" class="download-btn small">Download</a>
      </div>
      <div class="preview-content">
        <div class="markdown-body" x-html="renderedHtml"></div>
      </div>
    </div>
  </main>

  <!-- Log feed (during processing) -->
  <div class="log-feed" x-show="logs.length > 0 && !showPreview">
    <template x-for="(log, i) in logs.slice(-8)" :key="i">
      <div class="log-entry" :class="{ 'latest': i === logs.slice(-8).length - 1 }">
        <span class="log-time" x-text="log.time"></span>
        <span class="log-msg" x-text="log.message"></span>
      </div>
    </template>
  </div>

  <!-- Document outline (during preview) -->
  <div class="doc-outline" x-show="showPreview && outline.length > 0">
    <div class="outline-title">Outline</div>
    <template x-for="(item, i) in outline" :key="i">
      <div
        class="outline-entry"
        :class="'level-' + item.level"
        @click="scrollToHeading(item.id)"
      >
        <span class="outline-text" x-text="item.text"></span>
      </div>
    </template>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <a href="{{ url_for('index') }}" class="back-link">&larr; New</a>
  </footer>
</div>

<script>
function jobStatus(jobId, initialStatus, initialDownloadUrl, initialError) {
  return {
    status: initialStatus,
    downloadUrl: initialDownloadUrl,
    errorMsg: initialError,
    currentMessage: initialStatus === 'queued' ? 'Waiting in queue' : 'Connecting...',
    logs: [],
    eventSource: null,
    startTime: Date.now(),
    // Preview state
    showPreview: false,
    previewLoading: false,
    previewData: null,
    renderedHtml: '',
    outline: [],

    get isProcessing() {
      return this.status === 'queued' || this.status === 'processing';
    },

    get statusIcon() {
      const icons = {
        queued: '○',
        processing: '◐',
        done: '●',
        error: '✕'
      };
      return icons[this.status] || '?';
    },

    formatTime(timestamp) {
      const elapsed = Math.floor((timestamp * 1000 - this.startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      if (mins > 0) return `${mins}m ${secs}s`;
      return `${secs}s`;
    },

    addLog(message, timestamp) {
      const time = timestamp ? this.formatTime(timestamp) : '0s';
      this.logs.push({ time, message });
    },

    init() {
      this.addLog('Job started');
      if (this.isProcessing) {
        this.connect(jobId);
      } else if (this.status === 'done') {
        this.currentMessage = 'Complete';
        this.addLog('Download ready');
      } else if (this.status === 'error') {
        this.currentMessage = 'Failed';
        this.addLog(this.errorMsg || 'An error occurred');
      }
    },

    extractOutline(markdown) {
      // Extract headers from markdown
      const outline = [];
      const lines = markdown.split('\n');
      let headingCount = 0;

      for (const line of lines) {
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
          const level = match[1].length;
          let text = match[2].trim();
          // Remove markdown formatting from text
          text = text.replace(/\*\*(.+?)\*\*/g, '$1'); // bold
          text = text.replace(/\*(.+?)\*/g, '$1'); // italic
          text = text.replace(/`(.+?)`/g, '$1'); // code
          text = text.replace(/\[(.+?)\]\(.+?\)/g, '$1'); // links
          // Truncate long headers
          if (text.length > 50) {
            text = text.substring(0, 47) + '...';
          }
          const id = `heading-${headingCount++}`;
          outline.push({ level, text, id });
        }
      }
      return outline;
    },

    addHeadingIds(html, outline) {
      // Add IDs to headings in the HTML for scrolling
      let headingIndex = 0;
      return html.replace(/<(h[1-6])([^>]*)>/g, (match, tag, attrs) => {
        if (headingIndex < outline.length) {
          const id = outline[headingIndex].id;
          headingIndex++;
          return `<${tag}${attrs} id="${id}">`;
        }
        return match;
      });
    },

    scrollToHeading(id) {
      const element = document.getElementById(id);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    },

    renderMath(html) {
      // Helper function to render with KaTeX
      const renderTex = (tex, displayMode) => {
        try {
          return katex.renderToString(tex.trim(), {
            displayMode: displayMode,
            throwOnError: false,
            trust: true,
            strict: false
          });
        } catch (e) {
          console.warn('KaTeX error:', e);
          return null; // Return null to keep original on error
        }
      };

      // Process display math: $$...$$ and \[...\]
      html = html.replace(/\$\$([\s\S]*?)\$\$/g, (match, tex) => {
        const rendered = renderTex(tex, true);
        return rendered || `<span class="math-error">${match}</span>`;
      });

      html = html.replace(/\\\[([\s\S]*?)\\\]/g, (match, tex) => {
        const rendered = renderTex(tex, true);
        return rendered || `<span class="math-error">${match}</span>`;
      });

      // Process inline math: $...$ and \(...\)
      html = html.replace(/\\\(([\s\S]*?)\\\)/g, (match, tex) => {
        const rendered = renderTex(tex, false);
        return rendered || `<span class="math-error">${match}</span>`;
      });

      // Process $...$ last - be careful with currency
      html = html.replace(/\$([^\$\n]+?)\$/g, (match, tex) => {
        // Skip if it looks like currency (e.g., $100)
        if (/^\d/.test(tex.trim())) {
          return match;
        }
        const rendered = renderTex(tex, false);
        return rendered || match; // Keep original if render fails
      });

      return html;
    },

    async loadPreview() {
      if (this.previewLoading) return;
      this.previewLoading = true;

      try {
        const response = await fetch(`/job/${jobId}/preview`);
        if (!response.ok) {
          throw new Error('Failed to load preview');
        }
        this.previewData = await response.json();

        // Configure marked for safe HTML rendering
        marked.setOptions({
          breaks: true,
          gfm: true
        });

        // Process markdown - replace image references with actual URLs
        let markdown = this.previewData.markdown;

        // Replace image references like ![Image X.](img-1.webp) with full URLs
        const imageMap = {};
        this.previewData.images.forEach(img => {
          imageMap[img.filename] = img.url;
        });

        // Replace all image references
        markdown = markdown.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) => {
          // Handle both /img-1.webp and img-1.webp formats
          const filename = src.startsWith('/') ? src.slice(1) : src;
          const url = imageMap[filename] || src;
          return `![${alt}](${url})`;
        });

        // Extract document outline before rendering
        this.outline = this.extractOutline(markdown);

        // Protect math expressions before markdown parsing
        // (markdown parser can mangle backslashes in LaTeX)
        const mathPlaceholders = [];
        let protectedMarkdown = markdown;

        // Protect display math: $$...$$ and \[...\]
        protectedMarkdown = protectedMarkdown.replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
          const idx = mathPlaceholders.length;
          mathPlaceholders.push({ type: 'display', content: match });
          return `%%MATH_PLACEHOLDER_${idx}%%`;
        });
        protectedMarkdown = protectedMarkdown.replace(/\\\[([\s\S]*?)\\\]/g, (match) => {
          const idx = mathPlaceholders.length;
          mathPlaceholders.push({ type: 'display', content: match });
          return `%%MATH_PLACEHOLDER_${idx}%%`;
        });

        // Protect inline math: \(...\) and $...$
        protectedMarkdown = protectedMarkdown.replace(/\\\(([\s\S]*?)\\\)/g, (match) => {
          const idx = mathPlaceholders.length;
          mathPlaceholders.push({ type: 'inline', content: match });
          return `%%MATH_PLACEHOLDER_${idx}%%`;
        });
        protectedMarkdown = protectedMarkdown.replace(/\$([^\$\n]+?)\$/g, (match, tex) => {
          // Skip if it looks like currency
          if (/^\d/.test(tex.trim())) {
            return match;
          }
          const idx = mathPlaceholders.length;
          mathPlaceholders.push({ type: 'inline', content: match });
          return `%%MATH_PLACEHOLDER_${idx}%%`;
        });

        // Render markdown to HTML
        let html = marked.parse(protectedMarkdown);

        // Restore and render math expressions
        html = html.replace(/%%MATH_PLACEHOLDER_(\d+)%%/g, (match, idx) => {
          const placeholder = mathPlaceholders[parseInt(idx)];
          if (!placeholder) return match;
          return placeholder.content; // Return original, will be rendered by renderMath
        });

        // Add IDs to headings for scroll navigation
        html = this.addHeadingIds(html, this.outline);

        // Render LaTeX math expressions with KaTeX
        html = this.renderMath(html);

        this.renderedHtml = html;
        this.showPreview = true;
      } catch (e) {
        console.error('Preview load failed:', e);
        alert('Failed to load preview');
      } finally {
        this.previewLoading = false;
      }
    },

    connect(jobId) {
      this.eventSource = new EventSource(`/stream/${jobId}`);

      this.eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.status = data.status;

        if (data.message) {
          this.currentMessage = data.message;
          this.addLog(data.message, data.timestamp);
        }

        if (data.status === 'done') {
          this.downloadUrl = data.download_url;
          this.currentMessage = 'Complete';
          this.addLog('Download ready', data.timestamp);
          this.eventSource.close();
        } else if (data.status === 'error') {
          this.errorMsg = data.error || 'An error occurred';
          this.currentMessage = 'Failed';
          this.addLog(this.errorMsg, data.timestamp);
          this.eventSource.close();
        }
      };

      this.eventSource.onerror = () => {
        // Don't immediately show error - start polling instead
        this.eventSource.close();
        this.addLog('Connection interrupted, polling for status...');
        this.currentMessage = 'Reconnecting...';
        this.startPolling(jobId);
      };
    },

    startPolling(jobId) {
      // Poll every 5 seconds until job completes or errors
      this.pollInterval = setInterval(async () => {
        try {
          const response = await fetch(`/job/${jobId}/status`);
          const data = await response.json();

          this.status = data.status;

          if (data.status === 'done' && data.download_url) {
            this.downloadUrl = data.download_url;
            this.currentMessage = 'Complete';
            this.addLog('Download ready');
            clearInterval(this.pollInterval);
          } else if (data.status === 'error') {
            this.errorMsg = data.error || 'An error occurred';
            this.currentMessage = 'Failed';
            this.addLog(this.errorMsg);
            clearInterval(this.pollInterval);
          } else if (data.status === 'processing') {
            this.currentMessage = 'Processing...';
          }
        } catch (e) {
          // Keep polling even if one request fails
          console.log('Poll failed, retrying...', e);
        }
      }, 5000);
    }
  }
}
</script>
</body>
</html>
