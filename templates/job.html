<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Processing - MistraLOCR</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230c0c0c' width='100' height='100'/><text y='70' x='50' text-anchor='middle' font-size='60' fill='%23c8ff00'>O</text></svg>">
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}?v=6" />
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>

<div class="job-screen" x-data="jobStatus('{{ job_id }}', '{{ status }}', '{{ download_url|default('', true) }}', '{{ error|default('', true) }}')">
  <!-- Full screen grid background -->
  <div class="screen-grid" :class="{ 'active': isProcessing, 'success': status === 'done', 'error': status === 'error' }"></div>

  <!-- Header -->
  <header class="header">
    <a href="{{ url_for('index') }}" class="logo">MISTRALOCR</a>
    <div class="job-id">{{ job_id[:8] }}</div>
  </header>

  <!-- Center content -->
  <main class="job-center" :class="{ 'has-preview': showPreview }">
    <div class="job-status-box" x-show="!showPreview">
      <!-- Status symbol -->
      <div class="status-symbol" :class="status">
        <span x-text="statusIcon"></span>
      </div>

      <!-- Current message -->
      <div class="current-message" x-text="currentMessage"></div>

      <!-- Action buttons -->
      <div x-show="status === 'done'" x-transition class="action-buttons">
        <button @click="loadPreview()" class="preview-btn" :disabled="previewLoading">
          <span x-show="!previewLoading">Preview</span>
          <span x-show="previewLoading">Loading...</span>
        </button>
        <a :href="downloadUrl" class="download-btn">Download</a>
      </div>

      <!-- Error display -->
      <div x-show="status === 'error'" x-transition class="error-box">
        <span x-text="errorMsg"></span>
      </div>
    </div>

    <!-- Preview Panel -->
    <div x-show="showPreview" x-transition class="preview-panel">
      <div class="preview-header">
        <button @click="showPreview = false" class="close-preview-btn">&larr; Back</button>
        <div class="preview-title">Preview</div>
        <a :href="downloadUrl" class="download-btn small">Download</a>
      </div>
      <div class="preview-content">
        <div class="markdown-body" x-html="renderedHtml"></div>
      </div>
    </div>
  </main>

  <!-- Log feed -->
  <div class="log-feed" x-show="logs.length > 0">
    <template x-for="(log, i) in logs.slice(-8)" :key="i">
      <div class="log-entry" :class="{ 'latest': i === logs.slice(-8).length - 1 }">
        <span class="log-time" x-text="log.time"></span>
        <span class="log-msg" x-text="log.message"></span>
      </div>
    </template>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <a href="{{ url_for('index') }}" class="back-link">&larr; New</a>
  </footer>
</div>

<script>
function jobStatus(jobId, initialStatus, initialDownloadUrl, initialError) {
  return {
    status: initialStatus,
    downloadUrl: initialDownloadUrl,
    errorMsg: initialError,
    currentMessage: initialStatus === 'queued' ? 'Waiting in queue' : 'Connecting...',
    logs: [],
    eventSource: null,
    startTime: Date.now(),
    // Preview state
    showPreview: false,
    previewLoading: false,
    previewData: null,
    renderedHtml: '',

    get isProcessing() {
      return this.status === 'queued' || this.status === 'processing';
    },

    get statusIcon() {
      const icons = {
        queued: '○',
        processing: '◐',
        done: '●',
        error: '✕'
      };
      return icons[this.status] || '?';
    },

    formatTime(timestamp) {
      const elapsed = Math.floor((timestamp * 1000 - this.startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      if (mins > 0) return `${mins}m ${secs}s`;
      return `${secs}s`;
    },

    addLog(message, timestamp) {
      const time = timestamp ? this.formatTime(timestamp) : '0s';
      this.logs.push({ time, message });
    },

    init() {
      this.addLog('Job started');
      if (this.isProcessing) {
        this.connect(jobId);
      } else if (this.status === 'done') {
        this.currentMessage = 'Complete';
        this.addLog('Download ready');
      } else if (this.status === 'error') {
        this.currentMessage = 'Failed';
        this.addLog(this.errorMsg || 'An error occurred');
      }
    },

    async loadPreview() {
      if (this.previewLoading) return;
      this.previewLoading = true;

      try {
        const response = await fetch(`/job/${jobId}/preview`);
        if (!response.ok) {
          throw new Error('Failed to load preview');
        }
        this.previewData = await response.json();

        // Configure marked for safe HTML rendering
        marked.setOptions({
          breaks: true,
          gfm: true
        });

        // Process markdown - replace image references with actual URLs
        let markdown = this.previewData.markdown;

        // Replace image references like ![Image X.](img-1.webp) with full URLs
        const imageMap = {};
        this.previewData.images.forEach(img => {
          imageMap[img.filename] = img.url;
        });

        // Replace all image references
        markdown = markdown.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) => {
          // Handle both /img-1.webp and img-1.webp formats
          const filename = src.startsWith('/') ? src.slice(1) : src;
          const url = imageMap[filename] || src;
          return `![${alt}](${url})`;
        });

        // Render markdown to HTML
        this.renderedHtml = marked.parse(markdown);
        this.showPreview = true;
      } catch (e) {
        console.error('Preview load failed:', e);
        alert('Failed to load preview');
      } finally {
        this.previewLoading = false;
      }
    },

    connect(jobId) {
      this.eventSource = new EventSource(`/stream/${jobId}`);

      this.eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.status = data.status;

        if (data.message) {
          this.currentMessage = data.message;
          this.addLog(data.message, data.timestamp);
        }

        if (data.status === 'done') {
          this.downloadUrl = data.download_url;
          this.currentMessage = 'Complete';
          this.addLog('Download ready', data.timestamp);
          this.eventSource.close();
        } else if (data.status === 'error') {
          this.errorMsg = data.error || 'An error occurred';
          this.currentMessage = 'Failed';
          this.addLog(this.errorMsg, data.timestamp);
          this.eventSource.close();
        }
      };

      this.eventSource.onerror = () => {
        // Don't immediately show error - start polling instead
        this.eventSource.close();
        this.addLog('Connection interrupted, polling for status...');
        this.currentMessage = 'Reconnecting...';
        this.startPolling(jobId);
      };
    },

    startPolling(jobId) {
      // Poll every 5 seconds until job completes or errors
      this.pollInterval = setInterval(async () => {
        try {
          const response = await fetch(`/job/${jobId}/status`);
          const data = await response.json();

          this.status = data.status;

          if (data.status === 'done' && data.download_url) {
            this.downloadUrl = data.download_url;
            this.currentMessage = 'Complete';
            this.addLog('Download ready');
            clearInterval(this.pollInterval);
          } else if (data.status === 'error') {
            this.errorMsg = data.error || 'An error occurred';
            this.currentMessage = 'Failed';
            this.addLog(this.errorMsg);
            clearInterval(this.pollInterval);
          } else if (data.status === 'processing') {
            this.currentMessage = 'Processing...';
          }
        } catch (e) {
          // Keep polling even if one request fails
          console.log('Poll failed, retrying...', e);
        }
      }, 5000);
    }
  }
}
</script>
</body>
</html>
