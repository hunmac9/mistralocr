<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Processing - MistraLOCR</title>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>

<div class="job-page" x-data="jobStatus('{{ job_id }}', '{{ status }}', '{{ download_url or '' }}', '{{ error or '' }}')">
  <!-- Header -->
  <header class="header">
    <div class="logo">MISTRALOCR</div>
  </header>

  <!-- Main -->
  <main class="job-main">
    <div class="job-content">
      <div class="status-display">
        <!-- Status Indicator -->
        <div class="status-indicator">
          <div class="grid"></div>
          <div class="status-icon" :class="status" x-text="statusIcon"></div>
        </div>

        <!-- Status Text -->
        <div class="status-text" x-text="statusLabel"></div>

        <!-- Download Button (when done) -->
        <div x-show="status === 'done'" x-transition class="result-box success">
          <a :href="downloadUrl" class="download-btn">Download</a>
        </div>

        <!-- Error Message -->
        <div x-show="status === 'error'" x-transition class="result-box error">
          <p class="error-message" x-text="errorMsg"></p>
        </div>
      </div>

      <a href="{{ url_for('index') }}" class="back-link">&larr; New conversion</a>
    </div>
  </main>

  <!-- Footer -->
  <footer class="footer">
    <span class="limit">Job {{ job_id[:8] }}</span>
  </footer>
</div>

<script>
function jobStatus(jobId, initialStatus, initialDownloadUrl, initialError) {
  return {
    status: initialStatus,
    downloadUrl: initialDownloadUrl,
    errorMsg: initialError,
    eventSource: null,

    get isProcessing() {
      return this.status === 'queued' || this.status === 'processing';
    },

    get statusLabel() {
      const labels = {
        queued: 'Queued',
        processing: 'Processing',
        done: 'Complete',
        error: 'Failed'
      };
      return labels[this.status] || this.status;
    },

    get statusIcon() {
      const icons = {
        queued: '...',
        processing: '~',
        done: 'âœ“',
        error: '!'
      };
      return icons[this.status] || '?';
    },

    init() {
      if (this.isProcessing) {
        this.connect(jobId);
      }
    },

    connect(jobId) {
      this.eventSource = new EventSource(`/stream/${jobId}`);

      this.eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.status = data.status;

        if (data.status === 'done') {
          this.downloadUrl = data.download_url;
          this.eventSource.close();
        } else if (data.status === 'error') {
          this.errorMsg = data.error || 'An error occurred';
          this.eventSource.close();
        }
      };

      this.eventSource.onerror = () => {
        this.status = 'error';
        this.errorMsg = 'Connection lost';
        this.eventSource.close();
      };
    }
  }
}
</script>
</body>
</html>
